# 十大排序算法（Java实现）

排序是一个非常经典的问题，它以一定的顺序对一个数组（或一个列表）中的项进行重新排序（可以进行比较，例如整数，浮点数，字符串等）（增加，非递减，递减， 增加，词典等）。有许多不同的排序算法，每个都有其自身的优点和局限性。

学习前推荐一个可视化的网站[VISUALGO](https://visualgo.net/zh/sorting),简单直接看到排序的过程，神器一枚。还有[诺|言的十大排序算法全面解析-Java实现](https://juejin.im/post/5c40837751882525487c5394?utm_source=gold_browser_extension#heading-30)一文，本文章有图片和内容来源于此。

根据十大排序算法的实现原理以及效率可以按下图进行分类：

![](https://user-gold-cdn.xitu.io/2019/1/17/1685c01b19538a58?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

1. 非线性比较类排序：非线性是指算法的时间复杂度不能突破（nlogn），元素之间通过比较大小来决定先后顺序
2. 线性非比较类排序：算法的时间复杂度能够突破（nlogn），并且不通过比较来对元素排序

十大排序算法时间复杂度、空间复杂度、稳定性的比较：

![](https://user-gold-cdn.xitu.io/2019/1/17/1685c01b1b7d3d9a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

## 一 冒泡排序

对n个数进行排序，每次都是由前一个数跟后一个数比较，每循环一轮就可以将最大的数移到数组的最后，总共循环n-1轮，第i轮需要比较n-i-1次。

![](https://user-gold-cdn.xitu.io/2019/1/17/1685c01b1a3ac5e8?imageslim)

## 二 选择排序



选择排序是冒泡排序的改良版，与冒泡排序相比，比较次数是一样，但是交换次数大大减少了。选择排序不再是前一个数跟后一个数相比较， 而是在每一次循环内都由一个数去跟所有的数都比较一次，每次比较都选取相对较小的那个数来进行下一次的比较，并不断更新较小数的下标 这样在一次循环结束时就能得到最小数的下标，再通过一次交换将最小的数放在最前面，通过n-1次循环之后完成排序。

![](https://user-gold-cdn.xitu.io/2019/1/17/1685c01b2349fb70?imageslim)



## 三 插入排序

插入排序首先要默认数组的第一个数的排序位置是正确的了，然后取下一个数，与已经排序的数按从后往前的顺序依次比较，如果该数比当前位置排好序的数小，则将排好序的数的位置向后移一位。重复上一步骤，直到当j小于0或者该数大于arr[j-1]时，结束比较，并把该数放在arr[j]的位置。

![](https://user-gold-cdn.xitu.io/2019/1/17/1685c01b284a6b98?imageslim)

## 四 希尔排序

希尔排序也称为"缩小增量排序"，原理是先将需要排的数组分成多个子序列，这样每个子序列的元素个数就很少，再分别对每个对子序列进行插入排序。在该数组基本有序后 再进行一次直接插入排序就能完成对整个数组的排序。所以，要采用跳跃分割的策略。这里引入“增量”的概念，将相距某个增量的记录两两组合成一个子序列，然后对每个子序列进行直接插入排序， 这样得到的结果才会使基本有序（即小的在前边，大的在后边，不大不小的在中间）。希尔排序就是直接插入排序的升级版。

![](https://user-gold-cdn.xitu.io/2019/1/17/1685c01b7d4cfe55?imageslim)



## 五 归并排序

总体概括就是从上到下递归拆分，然后从下到上逐步合并。

**递归拆分**：先把待排序数组分为左右两个子序列，再分别将左右两个子序列拆分为四个子子序列，以此类推直到最小的子序列元素的个数为两个或者一个为止。

**逐步合并**（一定要注意是从下到上层级合并，可以理解为递归的层级返回）：将最底层的最左边的一个子序列排序，然后将从左到右第二个子序列进行排序，再将这两个排好序的子序列合并并排序，然后将最底层从左到右第三个子序列进行排序..... 合并完成之后记忆完成了对数组的排序操作

![](https://user-gold-cdn.xitu.io/2019/1/17/1685c01b7f84849b?imageslim)



## 六 快速排序

快速排序也采用了分治的策略，这里引入了‘基准数’的概念。

1. 找一个基准数（一般将待排序的数组的第一个数作为基准数）
2. 对数组进行分区，将小于等于基准数的全部放在左边，大于基准数的全部放在右边。
3. 重复1，2步骤，分别对左右两个子分区进行分区，一直到各分区只有一个数为止。

哈哈，有句话说天下武功唯快不破，快速排序是不是天下无敌了。

![](https://user-gold-cdn.xitu.io/2019/1/17/1685c01b83823cd8?imageslim)



## 七 堆排序

**堆**是一种特殊的完全二叉树，分为大顶堆和小顶堆。

**大顶堆**：每个结点的值都大于它的左右子结点的值，升序排序用大顶堆。

**小顶堆**：每个结点的值都小于它的左右子结点的值，降序排序用小顶堆。

所以，需要先将待排序数组构造成大顶堆的格式，这时候该堆的顶结点就是最大的数，将其与堆的最后一个结点的元素交换。再将剩余的树重新调整成堆，再次首节点与尾结点交换，重复执行直到只剩下最后一个结点完成排序。

![](https://user-gold-cdn.xitu.io/2019/1/17/1685c01bbe480b52?imageslim)



## 八 计数排序

计数排序采用了一种全新的思路，不再是通过比较来排序，而是将待排序数组中的最大值+1作为一个临时数组的长度，然后用临时数组记录待排序数组中每个元素出现的次数。最后再遍历临时数组，因为是升序，所以从前到后遍历，将临时数组中值>0的数的下标循环取出，依次放入待排序数组中，即可完成排序。计数排序的效率很高，但是实在牺牲内存的前提下，并且有着限制，那就是待排序数组的值必须 限制在一个确定的范围。

![](https://user-gold-cdn.xitu.io/2019/1/17/1685c01bbf2b9faf?imageslim)



## 九 桶排序

桶排序其实就是计数排序的强化版，需要利用一个映射函数首先定义有限个数个桶，然后将待排序数组内的元素按照函数映射的关系分别放入不同的桶里边，现在不同的桶里边的数据已经做了区分，比如A桶里的数要么全部大于B桶，要么全部小于B桶里的数。但是A，B桶各自里边的数还是乱序的。所以要借助其他排序方式（快速，插入，归并）分别对每一个元素个数大于一的桶里边的数据进行排序。最后再将桶里边的元素按照顺序依次放入待排序数组中即可。

![](https://user-gold-cdn.xitu.io/2019/1/17/1685c01bc021eb9f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



## 十 基数排序

就是将待排序数据拆分成多个**关键字**进行排序，也就是说，基数排序的实质是多关键字排序。多关键字排序的思路是将待排数据里德排序关键字拆分成多个排序关键字； 第1个排序关键字，第2个排序关键字，第3个排序关键字......然后，根据子关键字对待排序数据进行排序。

![](https://user-gold-cdn.xitu.io/2019/1/17/1685c01bd10a5893?imageslim)

